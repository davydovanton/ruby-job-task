# Тестовое задание

## Inventory service

### Как запустить

```
cd inventory-serivce
bundle
bundle exec rackup
```

### HTTP API documentation

- `GET /api/items` - возвращает список всех активных items
- `POST /api/item` - Создает новый активный айтем в системе
  - параметры: `{ "item": { "name": String, "price": Int } }`
  - пример body: `{ "item": { "name": "New item", "price": 4000 } }`
- `PUT /api/items/:id/toggle_status` - меняет статус айтема на противоположный, возвращает `ok`

## Описание тестового задания

Есть система, которая состоит из логики работы со складом и какими-то магазинами. Бизнес захотел добавить еще один магазин, что в тестовом задании надо будет и реализовать.

В сервисе склада реализованно 3 эндпоинта: создание товара и список всех товаров, а также изменение статуса товара по id. в момент создания товара отправляется событие которое слушается другими частями системы.

### Что необходимо сделать
1. Создание пользователей в магазине:
  - Необходимо создавать пользователя с именем и уникальным id, никаких авторизаций и аутентификаций делать не нужно. Только создание пользователя по `POST api/user`.
3. Логика работы магазина. Состоит из двух частей:
  - Отображение всех активных товаров со склада. Т.е. по `GET /api/items` необходимо показать все активные товары, которые есть на данный момент на складе.
  - checkout flow (покупка). Покупка должна происходить по вызову `/api/checkout` эндпоинта со списком item ids, которые окажутся в покупке + id пользователя который существует в системе.
    - во время выполнения checkout необходимо проверить пользователя и items на наличие. А также проверить, что пользователь выбрал 1+ item.
3. Payment flow
  - оплата должна быть изолирована от магазина, т.е. при упавшем магазине - оплата работает. И наоборот, при упавшей оплате - checkout работает.
  - Для оплаты необходимо знать две вещи: user id + цена ордера из checkout.
  - С точки зрения имплементации - достаточно вывести в консоль, что оплата для такого пользователя прошла.
  - Перевести цену с float на integer во всей системе.
  
### Технические требования
- Необходимо сделать самую простую реализацию из всех возможных
- Никакой аутентификации и авторизации в системе не нужно
- Технолоигии:
  - ruby + любой фреймворк и база данных, которую считаете нужными. Нагрузка на проект минимальна
  - message broker: так как система уже шлет событие из inventory сервиса - вам придется выбрать любую из технологий и реализовать транспорт для события.
- Магазин + оплата должны быть покрыты тестами

### Требование по реализации
- Проект должен быть сделан в приватном форке.
- Все части системы должны быть в одном репозитории.
